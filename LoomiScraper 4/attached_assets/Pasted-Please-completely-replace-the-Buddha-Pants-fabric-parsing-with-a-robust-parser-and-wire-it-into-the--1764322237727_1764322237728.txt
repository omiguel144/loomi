Please completely replace the Buddha Pants fabric parsing with a robust parser and wire it into the CSV builder.
The goal: for Buddha Pants, fabric_breakdown_pretty must contain all fiber percentages and sum to 100%, and fabric_tags must list the correct natural fibers (COTTON, LINEN, etc.).

1. Add a dedicated fabric parser module

Create a new file fabric_parser.py (or add near the top of main.py if you prefer), with the following code:
import re

# Known fiber keywords to detect real fiber phrases
FIBER_KEYWORDS = [
    "cotton",
    "organic cotton",
    "linen",
    "flax",
    "wool",
    "merino",
    "cashmere",
    "alpaca",
    "silk",
    "hemp",
    "bamboo",
    "viscose",
    "rayon",
    "modal",
    "polyester",
    "nylon",
    "spandex",
    "elastane",
    "acrylic",
]

# Map raw phrases to normalized tags
def normalize_fiber_family(base: str) -> str:
    b = base.lower()
    if "organic cotton" in b or "cotton" in b:
        return "COTTON"
    if "linen" in b or "flax" in b:
        return "LINEN"
    if "merino" in b:
        return "MERINO_WOOL"
    if "wool" in b:
        return "WOOL"
    if "cashmere" in b:
        return "CASHMERE"
    if "alpaca" in b:
        return "ALPACA"
    if "silk" in b:
        return "SILK"
    if "hemp" in b:
        return "HEMP"
    if "bamboo" in b:
        return "BAMBOO"
    if "viscose" in b or "rayon" in b or "modal" in b:
        return "REGENERATED_CELLULOSE"
    if "polyester" in b:
        return "POLYESTER"
    if "nylon" in b:
        return "NYLON"
    if "spandex" in b or "elastane" in b:
        return "ELASTANE"
    if "acrylic" in b:
        return "ACRYLIC"
    return base.strip().upper()


def is_fiber_phrase(text: str) -> bool:
    t = text.lower()
    return any(word in t for word in FIBER_KEYWORDS)


def clean_fiber_phrase(fiber_raw: str) -> str:
    """
    Trim marketing / garment text from the fiber phrase.
    Examples:
      'Organic Cotton – Your new favorite hoodie' -> 'Organic Cotton'
      'cotton harem pant that may remind you'     -> 'cotton'
    """
    s = fiber_raw.strip()

    # Cut at dash segments
    s = re.split(r"\s[-–—]\s", s)[0]

    # Cut at common sentence joiners
    for sep in [
        " with ",
        " that ",
        " which ",
        " featuring ",
        " crafted",
        " inspired",
        " perfect",
        " easily ",
    ]:
        lower = s.lower()
        idx = lower.find(sep)
        if idx != -1:
            s = s[:idx].strip()
            break

    # Cut when garment words start
    GARMENT_WORDS = [
        "hoodie",
        "jogger",
        "pant",
        "pants",
        "dress",
        "jumpsuit",
        "skirt",
        "shorts",
        "top",
        "tee",
        "t-shirt",
        "shirt",
        "sweater",
        "cardigan",
    ]
    lower = s.lower()
    cut_idx = None
    for gw in GARMENT_WORDS:
        idx = lower.find(" " + gw)
        if idx != -1:
            cut_idx = idx
            break
    if cut_idx is not None:
        s = s[:cut_idx].strip()

    # Remove trailing "solids", "prints", etc.
    s = re.sub(
        r"\b(solids?|prints?|pattern|exclusive of trim|shell|body)\b.*$",
        "",
        s,
        flags=re.IGNORECASE,
    ).strip()

    return s.strip()


def parse_fabric_breakdown(materials: str):
    """
    Robust parser for Loomi Buddha Pants.

    Input:  'Wildflower/Marble: 80% cotton, 20% linenSolids: 100% cottonEasily worn...'
    Output: ('80% cotton, 20% linen, 100% cotton', ['COTTON', 'LINEN'])

    We:
      - normalize the text
      - find ALL 'NN% <phrase>' matches
      - discard matches with no fiber word
      - clean fiber phrases
      - aggregate by fiber to avoid weird duplicates
    """
    if not materials:
        return None, []

    text = materials.replace("\u00a0", " ")

    # Avoid weird concatenations like 'linenSolids'
    text = re.sub(r"([a-z])([A-Z])", r"\1 \2", text)
    text = text.replace("/", ",")

    # Start from first percentage if present (skip leading marketing copy)
    first_pct = re.search(r"\d{1,3}\s*%", text)
    if first_pct:
        text = text[first_pct.start():]

    # Find ALL "NN% some words" patterns up to comma/semicolon/colon/period/newline
    matches = re.findall(
        r"(\d{1,3})\s*%\s*([A-Za-z][^,.;:%\n]+)",
        text,
    )

    if not matches:
        return None, []

    # Aggregate by normalized fiber family
    fiber_totals = {}  # family -> total percent
    fiber_labels = {}  # family -> canonical label (first seen)

    for pct_str, raw_phrase in matches:
        pct = int(pct_str)
        raw_phrase = raw_phrase.strip()

        # Skip things like "OFF EVERY" that do not contain fiber keywords
        if not is_fiber_phrase(raw_phrase):
            continue

        fiber_clean = clean_fiber_phrase(raw_phrase)
        if not fiber_clean or not is_fiber_phrase(fiber_clean):
            continue

        family = normalize_fiber_family(fiber_clean)
        fiber_totals[family] = fiber_totals.get(family, 0) + pct
        # remember the nicest label (first one)
        if family not in fiber_labels:
            fiber_labels[family] = fiber_clean

    if not fiber_totals:
        return None, []

    # Build sorted breakdown string from aggregated totals
    items = sorted(
        fiber_totals.items(),
        key=lambda kv: -kv[1],
    )

    breakdown_parts = []
    tags = []
    for family, pct in items:
        label = fiber_labels.get(family, family.title())
        breakdown_parts.append(f"{pct}% {label}")
        tags.append(family)

    breakdown = ", ".join(breakdown_parts)
    return breakdown, sorted(set(tags))
2. Use this parser in the Buddha Pants row builder

Find the code where the Buddha Pants product dict / CSV row is built (where we set materials_raw or materials_snippet and then fabric_breakdown_pretty / fabric_tags).
Replace the existing logic for those two fields with:
from fabric_parser import parse_fabric_breakdown

# inside the loop for each Buddha Pants product
materials_text = (
    product.get("materials_raw")
    or product.get("materials_snippet")
    or product.get("description")
    or ""
)

breakdown, tags = parse_fabric_breakdown(materials_text)

row["fabric_breakdown_pretty"] = breakdown
row["fabric_tags"] = " + ".join(tags) if tags else None
Make sure:
	•	The parser is called once per row.
	•	It uses the richest available materials field (snippet, raw, or description).

3. Add a tiny test harness so we can verify behavior

Add a new file test_fabric_parser.py (in the same project):
from fabric_parser import parse_fabric_breakdown

examples = [
    "100% Organic Cotton – Your new favorite hoodie",
    "80% cotton, 20% linen",
    "Wildflower/Marble: 80% cotton, 20% linenSolids: 100% cottonEasily worn...",
    "40% OFF EVERY HAREM PANT",  # should be ignored
]

for text in examples:
    breakdown, tags = parse_fabric_breakdown(text)
    print("RAW:", text)
    print(" -> breakdown:", breakdown)
    print(" -> tags:", tags)
    print("---")
I should be able to run:
python test_fabric_parser.py
and see:
	•	"100% Organic Cotton – Your new favorite hoodie"
→ breakdown: 100% Organic Cotton
→ tags: ['COTTON']
	•	"80% cotton, 20% linen"
→ breakdown: 80% cotton, 20% linen (order ok as long as 80 first)
→ tags: ['COTTON', 'LINEN']
	•	"Wildflower/Marble: 80% cotton, 20% linenSolids: 100% cottonEasily worn..."
→ breakdown includes both 80% cotton and 20% linen (and possibly 100% cotton as an extra component, depending on how you aggregate)
→ tags includes COTTON and LINEN
	•	"40% OFF EVERY HAREM PANT"
→ breakdown: None or ""
→ tags: []

4. Regenerate Buddha Pants CSV and verify

After these changes:
python main.py buddhapants
Then open the new buddhapants_raw.csv and confirm:
	•	Every row with a real fiber string has a multi-fiber fabric_breakdown_pretty that sums to ~100.
	•	fabric_tags contains clean, uppercased families: e.g. COTTON, LINEN, COTTON + LINEN, CASHMERE, etc.
	•	Promotional rows or weird non-fiber lines have empty fabric_breakdown_pretty and fabric_tags.

The priority is Buddha Pants. Please focus this parser on Buddha Pants patterns and make sure the output is clean enough for Loomi’s “natural fiber” logic.